package util

import (
	//	"bytes"
	"encoding/hex"
	"testing"
)

func TestUnDecodeLength(t *testing.T) {
	cases := []struct {
		in   int
		want int
	}{
		{1, 0},
		{2, 1},
		{3, 2},
		{4, 3},
		{5, 3},
		{6, 4},
		{7, 5},
		{8, 6},
		{9, 6},
		{10, 7},
		{11, 8},
		{38, 28},
		{192, 144},
		{512, 384},
	}

	for _, c := range cases {
		got := UnDecodeLength(c.in)
		if got != c.want {
			t.Errorf("UnDecodeLength(),given:%d, want %d, got %d", c.in, c.want, got)
		}
	}
}

func TestUnEncodeLength(t *testing.T) {
	cases := []struct {
		in   int
		want int
	}{
		{1, 2},
		{2, 3},
		{3, 4},
		{4, 6},
		{5, 7},
		{6, 8},
		{7, 10},
		{8, 11},
		{9, 12},
		{10, 14},
		{11, 15},
		{384, 512},
	}

	for _, c := range cases {
		got := UnEncodeLength(c.in)
		if got != c.want {
			t.Errorf("UnEncodeLength(),given:%d, want %d, got %d", c.in, c.want, got)
		}
	}
}

func TestUuDecode(t *testing.T) {
	cases := []struct {
		in   string
		want string
	}{

		{"202020202030202029523c202020202020202020202020202020202020202020202020202020", "00000001000027270000000000000000000000000000000000000000"},
		{"20202020202020202952402020202020202020235a202020202f4820202020232020202020202020202020", "000000000000272800000000000003e8000000fa000000030000000000000000"},
		{"20202020202020202952402020202021202020235a202020202f4820202020232020202020202020202020", "000000000000272800000001000003e8000000fa000000030000000000000000"},
		{"20202020203020203d3320202020202020202020202020202020202020202020202020202020", "00000001000075300000000000000000000000000000000000000000"},
		{"20202020202020202952402020202022202020235a202020202f4820202020232020202020202020202020", "000000000000272800000002000003e8000000fa000000030000000000000000"},
		{"202020203024394f3c462d4535272949383630402a25312d2a3020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020", "00000040466f72636554726961642028544d290000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},
		{"20202020203020202026302020202021", "000000010000006400000001"},
		{"2020202056202020295244202020202020202020202020202020202020202020202020202020", "000000d8000027290000000000000000000000000000000000000000"},
		{"202020203024394F3C462D4535272949383630402A25312D2A3020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020", "00000040466f72636554726961642028544d290000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},
		{"20202020203E5F4F5B5E5C2020202020305629535A34224020202020202020212F484A4A4B24205E335C3050423721592C5526483B33222A4A2C345D474B46202C2845503E3322343D294C5F402020382F5849225544292142483420202020204F5C442F5653562C222B54202020202020202020202020202020225F2F25332A4E5E3339282322293C273453343736392C284A48442358202F4E4050423721552C2845503D335E2020213C5F402020373044253B5C20202020202020202020202F385A284D5020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020", "00000001efefefef00000000436273e940a00000000000013e8aaaac403e4fc4308970793351a86d308aa8c53d9eb980308970793094749b3f8000183f8a42d642418a8500000000bfc90fdb3d8c08bd000000000000000000000000bf3c54cabbe4d9203089707533517599308aa8903e003ee830897075308970753f8000173f80001742415bf000000000000000003d8e88b70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},
		{"20202020203E5F4F5B5E5C20202020202F462D33353420595D403850423722472C55285C4323222A4A37265D3D4A49202C28455049532229434F505F402021582F58203C4E34292224435420202020204F5C442F5653562442224420202020202020202020202020202020", ""},
	}

	for _, c := range cases {
		input, _ := hex.DecodeString(c.in)
		got := UuDecode(input)
		output := hex.EncodeToString(got)
		if c.want != output {
			t.Errorf("UuDecode()\ngiven\t%s\nwant\t%s\ngot\t%s", c.in, c.want, output)
		}
	}

}

func TestUuEnocde(t *testing.T) {
	cases := []struct {
		in   string
		want string
	}{
		{"00000001000027270000000000000000000000000000000000000000", "202020202030202029523c202020202020202020202020202020202020202020202020202020"},
	}

	for _, c := range cases {
		input, _ := hex.DecodeString(c.in)
		got := UuEnocde(input)
		output := hex.EncodeToString(got)
		if c.want != output {
			//		if !bytes.Equal(got, c.want) {
			t.Errorf("UuEnocde()\ngiven\t%x\nwant\t%x\ngot\t%x", c.in, c.want, got)
		}
	}

}
